<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "https://mybatis.org/dtd/mybatis-3-mapper.dtd">
<!--
 1.这是一个mapper xml文件
 2.该文件可以去实现对应的接口的方法
 3.namespace用来指定该xml文件和哪个接口对应
 -->
<mapper namespace="com.gaoxi.mapper.MonsterMapper">
    <!-- 配置/实现方法addMonster
     1.id="addMonster" 就是接口的方法名
     2.parameterType="com.gaoxi.entity.Monster" 放入的形参的类型
     3.parameterType中的com.gaoxi.entity.Monster可以简写
     4.写入SQL语句=>，建议先在sequel ace里先写好，再复制过来，比较安全
     5.(`age`, `birthday`, `email`, `gender`, `name`, `salary`)表的字段
     6.(#{age}, #{birthday}, #{email}, #{gender}, #{name}, #{salary})是从传入的Monster对象属性传来的
     7.这里#{age} age对应Monster对象的属性名，其他一样
     -->
    <insert id="addMonster" parameterType="com.gaoxi.entity.Monster" useGeneratedKeys="true" keyProperty="id">
        INSERT INTO `monster`
        (`age`, `birthday`, `email`, `gender`, `name`, `salary`)
        VALUES (#{age}, #{birthday}, #{email}, #{gender}, #{name}, #{salary})
    </insert>
    <!-- 配置/实现delMonster()方法
     1.这里java.lang.Integer是Java类型，可以简写为Integer
     2.这里还要写入delete语句
     -->
    <delete id="delMonster" parameterType="java.lang.Integer">
        DELETE FROM monster WHERE id = #{id}
    </delete>
    <!-- 配置/实现updateMonster()方法
     1.com.gaoxi.entity.Monster 可以简写
     2.
     -->
<!--    <update id="updateMonster" parameterType="com.gaoxi.entity.Monster">-->
    <!-- 适用类型别名 -->
    <update id="updateMonster" parameterType="Monster">
        UPDATE `monster`
           SET `age` = #{age},
               `birthday` = #{birthday},
               `email` = #{email},
               `gender` = #{gender},
               `name` = #{name},
               `salary` = #{salary}
         WHERE id = #{id}
    </update>
    <!-- 配置/实现getMonsterById()方法 -->
    <select id="getMonsterById" resultType="Monster">
        SELECT * FROM `monster` WHERE id = #{id}
    </select>
    <!-- 配置/实现findAllMonster()方法 -->
    <select id="findAllMonster" resultType="Monster">
        SELECT * FROM `monster`
    </select>
    <!-- 配置/实现findMonserByNameOrId()方法 -->
    <select id="findMonsterByNameOrId" parameterType="com.gaoxi.entity.Monster" resultType="Monster">
        SELECT * FROM `monster` WHERE `id` = #{id} OR `name` = #{name}
    </select>
    <!-- 配置/实现findMonsterByName()方法 -->
    <!-- 如果是模糊查询，需要用${value}来接收参数 -->
    <select id="findMonsterByName" parameterType="java.lang.String" resultType="Monster">
<!--        SELECT * FROM `monster` WHERE `name` LIKE #{name}-->
        SELECT * FROM `monster` WHERE `name` LIKE '%${name}%'
    </select>
    <!-- 配置/实现findMonsterByIdAndSalary_ParameterHashMap，入参是HashMap -->
    <!-- 如果是以map形式传入参数，当以`id` > #{id}表示作为入参的map中有key为id的键值对 -->
    <!-- 使用map作为入参，可以摆脱POJO/Entity类属性的约束 -->
    <select id="findMonsterByIdAndSalary_ParameterHashMap" parameterType="map" resultType="Monster">
        SELECT * FROM `monster` WHERE `id` > #{id} AND `salary` > #{salary}
    </select>
    <!-- 配置/实现findMonsterByIdAndSalary_ParameterHashMap_ReturnHashMap，使用map作为入参以及返回的结果 -->
    <select id="findMonsterByIdAndSalary_ParameterHashMap_ReturnHashMap" parameterType="map" resultType="map">
        SELECT * FROM `monster` WHERE `id` > #{id} AND `salary` > #{salary}
    </select>

    <!-- 动态SQL -->
    <!--
     1.配置/实现方法public List<Monster> findMonsterByAge(@Param(value="age") Integer age)
     2.请查询age大于程序员输入的age的所有妖怪，如果程序员输入的age不大于0，则输出所有的妖怪
     3.如果按照以前的方式配置，会有什么问题？
     4.只有WHERE 1 = 1表示查询所有Monster
     5.如果使用原来的#{age}在test表达式中是取不出入参值的
     6.解决方案是使用@Param，在if:test中只使用age
     -->
    <select id="findMonsterByAge" resultType="Monster" parameterType="Integer">
        SELECT * FROM `monster` WHERE 1 = 1
        <if test="age >= 0">
            AND age > #{age}
        </if>
    </select>
    <!--
     配置/实现public List<Monster> findMonsterByIdAndName(Monster monster);
     如果入参是对象，test表达式中，直接使用对象的属性名即可
     where标签会在组织动态sql时，加上where，会去掉多余的and连接符
     -->
    <select id="findMonsterByIdAndName" parameterType="Monster" resultType="Monster">
        SELECT * FROM `monster`
        <where>
            <if test="id >= 0">
                AND `id` > #{id}
            </if>
            <if test="name != null and name != ''">
                AND `name` = #{name}
            </if>
        </where>
    </select>
    <!--
     1.配置/实现findMonsterByIdOrName_choose(Map<String, Object> map)
     2.入参是Map
     3.使用MyBatis提供的choose-when-otherwise标签
     -->
    <select id="findMonsterByIdOrName_choose" parameterType="map" resultType="Monster">
        SELECT * FROM `monster`
        <choose>
            <when test="name != null and name != ''">
                WHERE `name` = #{name}
            </when>
            <when test="id > 0">
                WHERE `id` > #{id}
            </when>
            <otherwise>
                WHERE `salary` > 100
            </otherwise>
        </choose>
    </select>
    <!--
     1.配置/实现findMonsterById_forEach
     2.查询id为3，5，7的Monster
     3.使用foreach标签
     4.入参map中会如何传入id值，key = ids - [集合，比如List 3, 5, 7]，即
       map入参中应当有ids-[3, 5, 7]
     -->
    <select id="findMonsterById_forEach" parameterType="map" resultType="Monster">
        SELECT * FROM `monster`
        <!-- 说明:
         1.where标签
         2.再写入相应的处理代码，比如判断ids是否为空
         3.如果ids不为空，则使用foreach标签进行遍历
         4.collection="ids" 对应入参map的key-ids
         5.item="id" 在遍历ids集合时，每次取出的值对应的变量名
         6.open="("对应的是sql id in (3, 5, 7)的左括号
         7.separator="," 遍历出来的多个值的分隔符号
         8.close=")"对应的是sql id in (3, 5, 7)的右括号
         9.#{id} 对应的就是item="id"
         -->
        <if test="ids != null and ids != ''">
            <where>
                id IN
                <foreach collection="ids" item="id" open="(" separator="," close=")">
                    #{id}
                </foreach>
            </where>
        </if>
    </select>
    <!--
     1.配置/实现public List<Monster> findMonsterByName_Trim(Map<String, Object> map)
     2.按名字和年龄查询Monster，如果sql语句开头有and | or，就替换成where
     3.如果要实现这个功能，使用where标签就可以实现，加入where，同时会去掉多余的and
     -->
    <select id="findMonsterByName_Trim" parameterType="map" resultType="Monster">
        SELECT * FROM `monster`
<!--        <where>-->
        <!-- 如果发现子句开头为 and 或者 or 或者 test，就去掉，并带上where -->
        <trim prefix="WHERE" prefixOverrides="and|or|test">
            <if test="name != null and name != ''">
                test `name` = #{name}
            </if>
            <if test="age != null and age != ''">
                AND `age` > #{age}
            </if>
        </trim>
<!--        </where>-->
    </select>
</mapper>